웹 분야에서 오래 일하면서 그냥 잘하는 사람과 진짜로 잘하는 사람을 구분하는 기준은
 “무엇을 아느냐”가 아니라 “어떻게 생각하느냐”라는 사실을 깨닫고 있다.

 -> 어떻게 생각하느냐 !!! 

```
나는 종종 그들에게 “왜 여기에 float: left를 추가한 겁니까?” 혹은 “여기에 overflow: hidden은 정말로 필요한 건가요?”라고 묻는다. 그럼 그들은 대부분 “몰라요. 하지만 제가 그걸 지우면 제대로 동작하지 않습니다.”라고 대답한다.
이거 없으면 동작하지를 않아서요 ??? !!! 아오... 나다 나 

```

### 명세(Spec)를 읽어라 

#### 유지보수 팀 

나는 실제로 새로운 엔지니어를 채용하는 면접 때, 그냥 완전히 새로운 코드를 작성하도록 시키는 것이 회사들의 가장 큰 실수 중 하나라고 생각한다. 내가 지금까지 면접을 보면서, 기존의 코드를 보여주면서 문제점을 찾고 그 문제를 해결하라고 요청받은 적이 없다는 사실이 안타깝다. 왜냐하면 엔지니어로서 대부분의 시간은 기존의 코드베이스를 유지보수하는데 쓰기 때문이다. 완전히 새로운 것을 구축할 일은 별로 없다.

- -> 그러게 또 반성한다. 난 어쩌면 굉장히 좋은 환경에 있었던 걸지도 ???
-> 다만 레거시 코드 퀄리티가...  -> 이걸 제대로 고치는게 실력 향상 ! 

#### 있는 걸 다시 만들어라


#### 배운 것을 기록해라 


1. 최근 한 프로젝트(미션풀이 등)에서 가장 어려웠던 점은 무엇이고, 어떻게 해결했는지?

최근에 한 프로젝트 중에서 가장 어려웠던 점이 무엇이고, 어떻게 해결 했는지? 

- 와 날 매번 와 이거 어렵다 어떻게 해결해야 되지 이정도로 어렵게 생각나고 기록할 정도로 몰아 넣어야 하는데 'ㅁ';;-> 아 몰라 -> 빨리 해결해버리자 이런식으로 접근하니까 남는게 없었다. 

- Prime Page vue1, vue2 jquery 모듈들이 제각각 분리가 되어 있고 코드들이 조금씩 다르고 스타일이나 레이아웃 구조가 다 달라서 이런 점을 맞추기가 매우 어려웠습니다. 그리고 이전에 작성된 코드들은 다른데랑 연결 된 부분이 있는지 이중으로 체크하고 전체 로직들도 파악해서 수정했을 때 영향을 미칠만한 요인이 있는지 디버깅 하는 과정이 어려웠습니다. 

- 최대한 재사용성이 있을 만한 부분 | 기본적으로 계속 반복적으로 하드 코딩 되는 부분을 컴포넌트로 빼서 중복을 피하려고 노력했습니다. 
- 기존에 메소드로 안 빠져 있고 if문 하드코딩이 연속으로 되어 있는 부분을 함수들로 빼서 보다 가독성을 높이고 동료들과 함께 컨벤션을 공유 했습니다. 
- 진행상황을 활발히 공유하고, 내가 어떤 부분을 진행해봤고 이렇게 진행해봤는데 막혔다. 이 부분 if문 두개를 하나로 줄이고 컴포넌트로 빼면 코드를 많이 줄 일 수 있을 것 같다. -> 히스토리가 어떤지 동료들에게 한 번 더 공통 책임이 되도록 체크를 한 번 부탁하면서 보완을 했던 것 같습니다. 


2. 브라우저의 렌더링 동작 과정을 짧게 설명해보시오 

브라우저가 사용자에게 url 요청을 받으면 
해당 url에 맞는 resource 위치를 dns를 통해서 전달 받아서 server에게 요청합니다.
html 웹 페이지를 그리는데 필요한  css,js , image resource등을 하나 하나씩 요청하면서 그리기 시작합니다. 

자 이제 브라우저 렌더링에 대해서 자세히 설명해보겠습니다. 
크게 다섯가지 과정을 통해서 진행됩니다. 


https://developers.google.com/web/fundamentals/performance/rendering/?hl=ko

1.
2.
3.
4. LayOut 단계
5. Composition 단계  
이 때 우선 html 문서 부터 하나씩 파싱해서 dom-tree 구조를 잡습니다. 그리고 style sheet, css를 parsing하면 
cssom tree을 작성합니다. 이 2과정을 합쳐서 어떻게 필요한 contents를 적절히 layout이나 색깔등을 입힐지 정보가 들어가 있는 renderTree를 만듭니다. 
renderTree를 바탕으로 LayOut을 작성합니다. 
// 여기서 막힘 

2. 브라우저의 랜더링 동작과정을 짧게 설명해 보세요.
3. Object.create의 역할은 무엇인가요?

말 그대로 객체를 생성하는데 파라미터로 받은 객체와 프로토타입 링크를 연결시키는 객체를 생성하게 됩니다. 



4. 자바스크립트 내에서 모듈내의 private한 속성을 만드는 방법을 아는대로 쓰세요.
5. JS에서 재귀호출로 인한 stack overflow를 막을 수 있는 방법은?

무한 루프에 빠지지 않게 하기 
성능상 메모이제이션을 활용할 수 있는지 살펴보기 
무한 루프에 있다면 비동기 루프로 돌릴 수 있게 처리하기 


6. closure와 스코프관계를 설명해 보세요.

외부에서도 자유변수를 참조하고 있으면 메모리가 죽지 않고 기억하고 있는 특정한 영역을 만들어야 되는데 이를 클로저라고 합니다. 

* [참고 32분]  - https://www.youtube.com/watch?v=h80tLv0fn88&t=3301s
코드 스피츠 
```
람다  - 루틴을 값으로 다를 수 있기 때문에  -> C 언의 함수 포인터로 부터 발전
런 타임 중에 루틴을 만들 수 있는 언어 

전역변수 , 지역변수 이외에도 내 flow상에서 기억해야 할 애들도 기억하게 
자유변수: 자기 지역이 아닌 변수 
루틴에서 자유변수를 참조하고 있으면 -> 해지가 안되고 닫힌 공간이 만들어지는데 
free values 를 가두는 공간을 클로저라고 합니다. 
es6 block scope 
-> 외부에서도 자기 자신 스코프가 아닌 자유변수를 참조하고 있으면 메모리가 해제를 안 하고 유지해야 하는데 이런 공간을 클로저라고 합니다. 

#### 클로저 사용 
1. Private 

```
function hello(name) {
  var _name = name;
  return function() {
    console.log('Hello, ' + _name);
  };
}
이런 경우 외부에서 접근할 방법이 없다. 


```
1.2 Private -> Symbol 을 활용하는 방법 

1.3 


클로저를 js에서 어떤 식으로 활용하는지 ? !!! 
- >  함수형에서 


```

+ 꼬리 물기 최적화 
루프 <-> 재귀 

연산자는 꼬리 물기 최적화를 방해한다. 
->연산자를 인자로 옮긴다.-> 기억할 필요 -> 받아서 처리 
js 삼항식 같은 if문은 스택 메모리를 일으키지 않음 = 논리 연산자들은 지연 평가를 함으로 
-> 내 꺼 찍어 놓지 말고 가지고 가 !!!

tail Recursion - 재귀 - 루프 이 부분을 자연스럽게 구현할 수 있는 연습을 많이 해놓을 것 !!! 
재귀-tail Recursion 형태로 짜는 것을 꼭 !!! 메모리 많이 잡아 먹지 않게 ! 

7. 본인이 경험한 OOP관점에서의 객체분리를 설명하고 느낀 장점을 말해보세요.


8. == 보다, ===를 써야 할 때는?

== 은 안티 패턴입니다. === 을 늘 씁니다. 왜냐하면 js spec 상 == 도 내부적으로늘 ===을 체크 한 후에 형변환이나 null, undefined같은 같은 얕은 빈 값으로 취급할 수 있는지 같은 부분을 체크하기 때문입니다. 
https://tc39.es/ecma262/#sec-equality-operators

9. DFS, BFS를 통한 트리탐색방법 중 본인이 경험(사용)했던 방식은 무엇이고, 동작원리를 짧게 설명해 보세요.

DFS 
BFS 

트리 탐색 방법 -> 동작원리 


10. ES6의 class extends내부 동작원리에 대해서 설명해보세요.

11. 객체를 탐색하는 방법에 대해서 2가지를 작성해 보세요.

12. arrow함수의 this가 결정되는 방식을 설명해보세요.

13. immutable과 mutable은 무엇이 다른 것인가요?


14. undefined와 null 의 차이점을 설명하세요.

15. ECMAScript는 무엇인가요?

16. 아래처럼 동작하는 flatten 함수를 reduce를 활용해서 만들어 보세요.

const arr = [[1,2],[3,4],[5,6]];
const flattenedArray = flatten(arr);
console.log(flattenedArray) //[1,2,3,4,5,6];

17. 객체를 복사해서 새로운 객체를 만들고 싶습니다. 코드를 구현해 보세요.(객체의 깊이는 1단계만 있다고 가정합니다.

얕은 복사 (assign, spread, create)등을 활용하여 얕은 복사를 구현할 수 있습니다. 
```
Object.assign({}, a,b,c)
{...}
```
+ 
깊은 복사를 코드상으로 구현 해보시오 (라이브러리 lodash, )

18. Array.from이 모든 부라우저에서 동작하도록 polyfill코드를 만들어 보세요.

```
Array.from 의 역할은 유사배열을 배열로 만들어 주는 역할을 합니다. 

if(!Array.from){
  Array.prototype.from = function(arrayLike){
      return [].slice.call(arrayLike);
  }
}

```


19. 프로그래밍 요구사항을 받았을 때, 구현하기 전까지 어떤 과정을 거치나요?

- 기획에 같이 참여하면서 요구사항을 체크하면 더 베스트 이고요
- 그렇지 못 한 경우 스펙을 보면서 왜 이걸 구현하는지 | 필요성이 납득이 가는지? 보완할 점이 없는지 체크해봅니다. 
납득이 많이 가는 경우 -> User 입장에서 페이지 들어가서 flow에 부 자연 스러운 부분이나 이해가 잘 안 가는 부분 없는지 체크해보고, 이런 부분이 발생하면 같이 한 번 더 기획자와 더블 체크합니다.
- 요구사항들과 코드를 러프하게 살펴보면서 백엔드나 디자이너와 같이 맞춰봐야 할 것 과 프론트의 요구사항을 참고해서 일정을 산정합니다. 
- 디자이너와 백엔드에게 필요한 요구사항 부터 먼저 알려주고 -> 가장 먼저 처리해주거나 이런 부분을 고려하면 좋을 것 같다는 점을 정리해서 한 번 같이 체크를 해서 전달해드립니다. 
- 프론트엔드 코드만으로 바로 들어갈 수 있는 부분들은 바로 작업을 들어갑니다. 




옛날 면접 질문들 

1. 동기 비동기 차이
2. Closure가 뭔지 어떻게 써봤냐?
3. Vue React 차이
4. 성능 Front-end에서 2초나 걸린다 어떻게 할 것인지
5. 보통 문제들을 어떻게 해결하는지
6. Host객체와 Native객체 차이?
7. 오픈소스 기여해보거나 커뮤니티에 속한 것이 있냐?
8. 속도랑 꼼꼼함 어느 것을 더 추구하는 성향인지 ?
9. 전자과인데 자료구구조나 CS과목 수강한 것이 있는지?
10. Component나 객체 설계 어떻게 하는지?
11.프로젝트에 대한 설명 :
11. React-Native에 대해서 관심 있는지?
12. 자신에 장점이 무엇인지?
13. 어떤 회사에 가고 싶은지?
물어볼 만한 것 자유롭게 물어봐라
회사에 어떤 걸 물어봐야 될지 맨날 잘 모르겠네요 ?
14. 회사 협업 워크플로우


1. closure 와 스코프관계를 설명해보세요
2. prototype 의 동작방식에 대해서 설명해보세요.

js객체가 확장을 할 때 prototype 기반으로 연결 되어 확장을 합니다. 
```
Object.setPrototype
Object.create
Class extends 같은 방식으로 객체를 확장합니다.  
```
다른 클래스 기반에 확장 방법 보다 메모리상 효율적인 이점이 있습니다. 



3. event delegation이 무엇인가요?

부모객체에서 이벤트를 위임받아 버블링으로 이벤트를 잡아서 처리하는 기법입니다. 특히 이렇게 처리하게 되면 다수의 자식들에게 일일이 
이벤트를 등록할 필요 없고 새로운 것이 추가되거나 제거 됬을때 다시 해제하거나 제거할 일도 없습니다. 

4. 비동기가 연속되어 있는 경우에 어떤방식으로 처리하세요?

Promise.all
혹은 
async await로 순서를 보장해서 처리 

5. 본인이 하는 JavaScript 디버깅방법에 대해서 설명해보세요.

에러메시지 파악
크롬 브라우저에서 콘솔과 debugger을 통해서 해당 함수나 로직에 문제가 없는지 하나씩 추적하는 방식으로 수행하는 편입니다. 
-> 

6. 계속 돌아가는 캐로셀UI의 구현 원리에 대해서 설명해보세요.

7. getelementById , getElementsByClassName 메서드 중 어떤 것이 더 빠를까요? 그 이유는?
getElementById -> id는 하나 발견되면 멈추기 때문에 id selector로 접근해서 찾을 수 있는 경우 찾는 편입니다. 
8. NodeList의 결과를 Array에 있는 reduce메서드를 사용할 수 있나요? 방법은?

Array.from | spreadOperator

9. Event 객체에 대해서 설명해보세요.



10. Ajax요청시 크로스 도메인 문제를 어떻게 해결할 수 있나요?

11. iteration protocol에 대해서 설명해보세요.

12. script 태그안에 defer나, async 속성에 대해서 설명해보세요.

13. 웹사이트의 초기 로딩속도를 더 빠르게 하기 위해서 무엇을 해야 할까요?

14. SET과 Array 자료구조의 차이점은 무엇인가요?

15. 커링으로 동작하는 코드를 간단하게 보여주세요.

16. 최근 가장 깊게 공부하고 있는 부분은 무엇인가요?  그 부분에 대해서 간단하게 설명해보세요.

- git 
-> git의 내부 구조 
-> commit , head 


17. 브라우저 호환성 이슈가 있는 최신의 native method를 어떻게 실제 서비스에서 사용할 수 있나요?

```
function curry( fn ) {
  var arity = fn.lengthgit;
  return (function resolver() {
    var memory = Array.prototype.slice.call( arguments );
    return function() {
    };
  }());
}

```


여러분이 브라우저에 웹 주소를 입력할 때 (우리의 비유에서 상점으로 걸어가는 것과 유사합니다):

브라우저는 DNS 서버로 가서 웹사이트가 있는 서버의 진짜 주소를 찾습니다 (여러분이 상점의 주소를 찾습니다).
그 다음 브라우저는 서버에게 웹사이트의 사본을 클라이언트에게 보내달라는 HTTP 요청 메세지를 서버로 전송합니다.(상점으로 가서 상품을 주문합니다.) 이 메세지, 그리고 클라이언트와 서버 사이에 전송된 모든 데이터는 TCP/IP 연결을 통해서 전송됩니다.
이 메세지를 받은 서버는 클라이언트의 요청을 승인하고, "200 OK" 메세지를 클라이언트에게 전송합니다. "200 OK"는 "물론이죠. 당신은 웹 사이트를 볼 수 있어요! 여기 있어요" 라는 의미입니다. 그 다음 서버는 웹사이트의 파일들을 데이터 패킷이라 불리는 작은 일련의 덩어리들로 브라우저에 전송하기 시작합니다.(상점은 여러분이 주문한 상품을 전달하고, 여러분은 그것을 집으로 가져갑니다.)
브라우저는 이 작은 덩어리들을 완전한 웹 사이트로 조립하고, 당신에게 보여줍니다. (상품이 당신의 문에 도착합니다. — 새 것이죠, 멋져요!)


```
function curry(func) {
  return function nest(...args) {
    if (args.length >= func.length) {
      return func(...args);
    }
    return (...nextArgs) => nest(...args, ...nextArgs);
  }
}


```